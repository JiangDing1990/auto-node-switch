import fs from 'node:fs';
import path from 'node:path';
import os from 'node:os';
import type {WorkdirConfig} from './config.js';
import {Security} from './security.js';

const HOME = os.homedir();

const HOOK_MARKER = '# Node.js Â∑•‰ΩúÁõÆÂΩïÁéØÂ¢ÉÂàáÊç¢';
const HOOK_END_MARKER = '# Node.js Â∑•‰ΩúÁõÆÂΩïÁéØÂ¢ÉÂàáÊç¢ END';
const POWERSHELL_HOOK_MARKER = '# Node.js Â∑•‰ΩúÁõÆÂΩïÁéØÂ¢ÉÂàáÊç¢';
const POWERSHELL_HOOK_END_MARKER = '# Node.js Â∑•‰ΩúÁõÆÂΩïÁéØÂ¢ÉÂàáÊç¢ END';

/**
 * Hook ÁÆ°ÁêÜÁ±ª
 */
export class HookManager {
	/**
	 * ÁîüÊàêÁâàÊú¨Ê£ÄÊµãÁöÑ JavaScript ‰ª£Á†ÅÔºàÁî®‰∫éÂµåÂÖ• shell hookÔºâ
	 */
	private static generateVersionDetectionJS(manager: string): string {
		const isForN = manager === 'n';
		const versionFiles = isForN
			? "'.node-version', '.nvmrc'"
			: "'.nvmrc', '.node-version'";
		const sourceFileDesc = isForN
			? '".node-versionÊàñ.nvmrc"'
			: '".nvmrcÊàñ.node-version"';

		return `
      const fs = require('fs');
      const path = require('path');
      const workdirs = JSON.parse(fs.readFileSync(0, 'utf8'));
      const cwd = process.cwd();
      
      // ÁâàÊú¨Êñá‰ª∂ËØªÂèñÂáΩÊï∞
      function readVersionFile(projectDir) {
        const versionFiles = [${versionFiles}];
        
        for (const fileName of versionFiles) {
          const filePath = path.join(projectDir, fileName);
          try {
            if (fs.existsSync(filePath)) {
              const content = fs.readFileSync(filePath, 'utf8').trim();
              if (content) return content.replace(/^v/, '');
            }
          } catch (e) { /* ignore */ }
        }
        
        // Ê£ÄÊü• package.json ÁöÑ engines.node
        try {
          const pkgPath = path.join(projectDir, 'package.json');
          if (fs.existsSync(pkgPath)) {
            const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
            const nodeVersion = pkg.engines && pkg.engines.node;
            if (nodeVersion) {
              const match = nodeVersion.match(/(\\\\d+\\\\.\\\\d+\\\\.\\\\d+|\\\\d+\\\\.\\\\d+|\\\\d+)/);
              return match ? match[1] : null;
            }
          }
        } catch (e) { /* ignore */ }
        return null;
      }
      
      // 1. ‰ºòÂÖàÊü•ÊâæËÑöÊú¨ÈÖçÁΩÆÁöÑÂ∑•‰ΩúÁõÆÂΩï
      let bestMatch = null;
      let bestLength = -1;
      
      for (const w of workdirs) {
        if (cwd === w.dir || cwd.startsWith(w.dir + '/')) {
          if (w.dir.length > bestLength) {
            bestMatch = w;
            bestLength = w.dir.length;
          }
        }
      }
      
      if (bestMatch) {
        const dirName = path.basename(bestMatch.dir);
        console.log(\\\`\\\${bestMatch.version}|config|\\\${dirName}\\\`);
        return;
      }
      
      // 2. Â¶ÇÊûúÊ≤°ÊúâËÑöÊú¨ÈÖçÁΩÆÔºåÂ∞ùËØïËØªÂèñÁâàÊú¨Êñá‰ª∂
      const fileVersion = readVersionFile(cwd);
      if (fileVersion) {
        const dirName = path.basename(cwd);
        const sourceFile = ${sourceFileDesc};
        console.log(\\\`\\\${fileVersion}|file|\\\${dirName}|\\\${sourceFile}\\\`);
        return;
      }
  `
			.replace(/\n\s*/g, ' ')
			.trim();
	}

	/**
	 * ‰∏∫ Bash/Zsh ÁîüÊàê Hook
	 */
	private static generateBashHook(
		manager: string,
		workdirs: WorkdirConfig[],
	): string {
		const dirsJson = JSON.stringify(workdirs);
		const escapedDirsJson = Security.escapeShellString(dirsJson);

		// ÁîüÊàêÁâàÊú¨Ê£ÄÊµãÁöÑ JavaScript ‰ª£Á†Å
		const versionDetectionJS = this.generateVersionDetectionJS(manager);

		let nvmPath = '';
		if (manager === 'nvm') {
			const nvmPaths = [
				path.join(HOME, '.nvm/nvm.sh'),
				'/usr/local/share/nvm/nvm.sh',
				'/opt/homebrew/share/nvm/nvm.sh',
			];
			nvmPath =
				nvmPaths.find(p => fs.existsSync(p)) || path.join(HOME, '.nvm/nvm.sh');
		}

		if (manager === 'nvm') {
			return `${HOOK_MARKER}
npm() {
  local WORKDIRS='${escapedDirsJson}'
  local TARGET_VERSION=""
  local PREVIOUS_VERSION=""

  # Ëé∑ÂèñÂΩìÂâç Node ÁâàÊú¨
  if command -v node >/dev/null 2>&1; then
    PREVIOUS_VERSION="$(node -v 2>/dev/null | sed 's/^v//')"
  fi

  # Ê£ÄÊü•ÊòØÂê¶Âú®Â∑•‰ΩúÁõÆÂΩï‰∏≠
  if [ -n "$WORKDIRS" ]; then
    local WORKDIR_INFO=$(echo "$WORKDIRS" | node -e '${versionDetectionJS}' 2>/dev/null)
    
    if [ -n "$WORKDIR_INFO" ]; then
      TARGET_VERSION="\${WORKDIR_INFO%%|*}"
      local VERSION_SOURCE="\$(echo "$WORKDIR_INFO" | cut -d'|' -f2)"
      local WORKDIR_NAME="\$(echo "$WORKDIR_INFO" | cut -d'|' -f3)"
      local SOURCE_FILE="\$(echo "$WORKDIR_INFO" | cut -d'|' -f4)"
      
      if [ "$VERSION_SOURCE" = "config" ]; then
        echo "üìÅ Ê£ÄÊµãÂà∞ÈÖçÁΩÆÈ°πÁõÆ: \$WORKDIR_NAME (Node \$TARGET_VERSION)"
      else
        echo "üìÅ Ê£ÄÊµãÂà∞È°πÁõÆÁâàÊú¨Êñá‰ª∂: \$WORKDIR_NAME (Node \$TARGET_VERSION from \$SOURCE_FILE)"
      fi
    fi
  fi

  # ÁâàÊú¨ÂàáÊç¢ÂíåÊÅ¢Â§çÊú∫Âà∂
  local NEED_RESTORE=0
  
  if [ -n "$TARGET_VERSION" ] && [ "$TARGET_VERSION" != "$PREVIOUS_VERSION" ]; then
    echo "üîÑ ÂàáÊç¢ Node ÁâàÊú¨: \$PREVIOUS_VERSION -> \$TARGET_VERSION"
    source "${nvmPath}" >/dev/null 2>&1
    nvm use "$TARGET_VERSION" >/dev/null 2>&1
    if [ $? -ne 0 ]; then
      echo "‚ö†Ô∏è ÁâàÊú¨ $TARGET_VERSION ‰∏çÂ≠òÂú®ÔºåÂ∞ùËØïÂÆâË£Ö..."
      nvm install "$TARGET_VERSION" >/dev/null 2>&1 && nvm use "$TARGET_VERSION" >/dev/null 2>&1
    fi
    
    # ËÆæÁΩÆÊÅ¢Â§çÊú∫Âà∂
    trap "echo 'üì¶ ÊâßË°åÂÆåÊàêÔºåÊÅ¢Â§çÂà∞‰πãÂâçÁöÑ Node.js ÁâàÊú¨...'; echo '‚Ü©Ô∏è ÊÅ¢Â§ç Node ÁâàÊú¨: \$TARGET_VERSION -> \$PREVIOUS_VERSION'; source '${nvmPath}' >/dev/null 2>&1; nvm use '\$PREVIOUS_VERSION' >/dev/null 2>&1" INT
    trap "echo 'üì¶ ÊâßË°åÂÆåÊàêÔºåÊÅ¢Â§çÂà∞‰πãÂâçÁöÑ Node.js ÁâàÊú¨...'; echo '‚Ü©Ô∏è ÊÅ¢Â§ç Node ÁâàÊú¨: \$TARGET_VERSION -> \$PREVIOUS_VERSION'; source '${nvmPath}' >/dev/null 2>&1; nvm use '\$PREVIOUS_VERSION' >/dev/null 2>&1" EXIT
  fi

  # ÊâßË°å npm ÂëΩ‰ª§
  command npm "$@"
  local exit_code=$?
  
  # Ê≠£Â∏∏ÂÆåÊàêÊó∂ÊÅ¢Â§çÁâàÊú¨ÔºàÈÄöËøáEXIT trapËá™Âä®Â§ÑÁêÜÔºâ
  return $exit_code
}
${HOOK_END_MARKER}
`;
		}

		if (manager === 'n') {
			return `${HOOK_MARKER}
npm() {
  local WORKDIRS='${escapedDirsJson}'
  local TARGET_VERSION=""
  local PREVIOUS_VERSION=""

  # Ëé∑ÂèñÂΩìÂâç Node ÁâàÊú¨
  if command -v node >/dev/null 2>&1; then
    PREVIOUS_VERSION="$(node -v 2>/dev/null | sed 's/^v//')"
  fi

  # Ê£ÄÊü•ÊòØÂê¶Âú®Â∑•‰ΩúÁõÆÂΩï‰∏≠
  if [ -n "$WORKDIRS" ]; then
    local WORKDIR_INFO=$(echo "$WORKDIRS" | node -e '${versionDetectionJS}' 2>/dev/null)
    
    if [ -n "$WORKDIR_INFO" ]; then
      TARGET_VERSION="\${WORKDIR_INFO%%|*}"
      local VERSION_SOURCE="\$(echo "$WORKDIR_INFO" | cut -d'|' -f2)"
      local WORKDIR_NAME="\$(echo "$WORKDIR_INFO" | cut -d'|' -f3)"
      local SOURCE_FILE="\$(echo "$WORKDIR_INFO" | cut -d'|' -f4)"
      
      if [ "$VERSION_SOURCE" = "config" ]; then
        echo "üìÅ Ê£ÄÊµãÂà∞ÈÖçÁΩÆÈ°πÁõÆ: \$WORKDIR_NAME (Node \$TARGET_VERSION)"
      else
        echo "üìÅ Ê£ÄÊµãÂà∞È°πÁõÆÁâàÊú¨Êñá‰ª∂: \$WORKDIR_NAME (Node \$TARGET_VERSION from \$SOURCE_FILE)"
      fi
    fi
  fi

  # ÁâàÊú¨ÂàáÊç¢ÂíåÊÅ¢Â§çÊú∫Âà∂
  if [ -n "$TARGET_VERSION" ] && [ "$TARGET_VERSION" != "$PREVIOUS_VERSION" ]; then
    echo "üîÑ ÂàáÊç¢ Node ÁâàÊú¨: \$PREVIOUS_VERSION -> \$TARGET_VERSION"
    
    # Ê£ÄÊü•ÁâàÊú¨ÊòØÂê¶Â≠òÂú®ÔºåÂ¶Ç‰∏çÂ≠òÂú®ÂàôÂÆâË£Ö
    if ! n ls 2>/dev/null | grep -q "$TARGET_VERSION"; then
      echo "‚ö†Ô∏è ÁâàÊú¨ $TARGET_VERSION ‰∏çÂ≠òÂú®ÔºåÊ≠£Âú®ÂÆâË£Ö..."
      n install "$TARGET_VERSION" >/dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "‚ùå ÁâàÊú¨ $TARGET_VERSION ÂÆâË£ÖÂ§±Ë¥•ÔºåÂ∞Ü‰ΩøÁî®ÂΩìÂâçÁâàÊú¨"
        TARGET_VERSION="$PREVIOUS_VERSION"
      else
        echo "‚úÖ ÁâàÊú¨ $TARGET_VERSION ÂÆâË£ÖÊàêÂäü"
      fi
    fi
    
    if [ "$TARGET_VERSION" != "$PREVIOUS_VERSION" ]; then
      n "$TARGET_VERSION" >/dev/null 2>&1
    fi
    
    # ËÆæÁΩÆÊÅ¢Â§çÊú∫Âà∂
    trap "echo 'üì¶ ÊâßË°åÂÆåÊàêÔºåÊÅ¢Â§çÂà∞‰πãÂâçÁöÑ Node.js ÁâàÊú¨...'; echo '‚Ü©Ô∏è ÊÅ¢Â§ç Node ÁâàÊú¨: \$TARGET_VERSION -> \$PREVIOUS_VERSION'; n '\$PREVIOUS_VERSION' >/dev/null 2>&1" INT
    trap "echo 'üì¶ ÊâßË°åÂÆåÊàêÔºåÊÅ¢Â§çÂà∞‰πãÂâçÁöÑ Node.js ÁâàÊú¨...'; echo '‚Ü©Ô∏è ÊÅ¢Â§ç Node ÁâàÊú¨: \$TARGET_VERSION -> \$PREVIOUS_VERSION'; n '\$PREVIOUS_VERSION' >/dev/null 2>&1" EXIT
  fi

  # ÊâßË°å npm ÂëΩ‰ª§
  command npm "$@"
  local exit_code=$?
  
  # Ê≠£Â∏∏ÂÆåÊàêÊó∂ÊÅ¢Â§çÁâàÊú¨ÔºàÈÄöËøáEXIT trapËá™Âä®Â§ÑÁêÜÔºâ
  return $exit_code
}
${HOOK_END_MARKER}
`;
		}

		return '';
	}

	/**
	 * ‰∏∫ Fish Shell ÁîüÊàê Hook
	 */
	private static generateFishHook(
		manager: string,
		workdirs: WorkdirConfig[],
	): string {
		const dirsJson = JSON.stringify(workdirs);
		const escapedDirsJson = Security.escapeShellString(dirsJson);

		// ÁîüÊàêÁâàÊú¨Ê£ÄÊµãÁöÑ JavaScript ‰ª£Á†ÅÔºà‰∏é Bash ÁâàÊú¨Áõ∏ÂêåÔºâ
		const versionDetectionJS = this.generateVersionDetectionJS(manager);

		if (manager === 'nvm') {
			const nvmPaths = [
				path.join(HOME, '.nvm/nvm.sh'),
				'/usr/local/share/nvm/nvm.sh',
				'/opt/homebrew/share/nvm/nvm.sh',
			];
			const nvmPath =
				nvmPaths.find(p => fs.existsSync(p)) || path.join(HOME, '.nvm/nvm.sh');

			return `${HOOK_MARKER}
function npm
    set WORKDIRS '${escapedDirsJson}'
    set TARGET_VERSION ""
    set PREVIOUS_VERSION ""
    
    # Ëé∑ÂèñÂΩìÂâç Node ÁâàÊú¨
    if command -v node >/dev/null 2>&1
        set PREVIOUS_VERSION (node -v 2>/dev/null | sed 's/^v//')
    end
    
    # Ê£ÄÊü•ÊòØÂê¶Âú®Â∑•‰ΩúÁõÆÂΩï‰∏≠ÔºàÊîØÊåÅ .nvmrc/.node-version Êñá‰ª∂Ê£ÄÊµãÔºâ
    if test -n "$WORKDIRS"
        set WORKDIR_INFO (echo "$WORKDIRS" | node -e '${versionDetectionJS}' 2>/dev/null)
        
        if test -n "$WORKDIR_INFO"
            set TARGET_VERSION (echo "$WORKDIR_INFO" | cut -d'|' -f1)
            set VERSION_SOURCE (echo "$WORKDIR_INFO" | cut -d'|' -f2)
            set WORKDIR_NAME (echo "$WORKDIR_INFO" | cut -d'|' -f3)
            set SOURCE_FILE (echo "$WORKDIR_INFO" | cut -d'|' -f4)
            
            if test "$VERSION_SOURCE" = "config"
                echo "üìÅ Ê£ÄÊµãÂà∞ÈÖçÁΩÆÈ°πÁõÆ: $WORKDIR_NAME (Node $TARGET_VERSION)"
            else
                echo "üìÅ Ê£ÄÊµãÂà∞È°πÁõÆÁâàÊú¨Êñá‰ª∂: $WORKDIR_NAME (Node $TARGET_VERSION from $SOURCE_FILE)"
            end
        end
    end
    
    # ÂàáÊç¢Âà∞ÁõÆÊ†áÁâàÊú¨
    if test -n "$TARGET_VERSION" -a "$TARGET_VERSION" != "$PREVIOUS_VERSION"
        echo "üîÑ ÂàáÊç¢ Node ÁâàÊú¨: $PREVIOUS_VERSION -> $TARGET_VERSION"
        
        # Á°Æ‰øù nvm Â∑≤Âä†ËΩΩ
        if not type -q nvm
            if test -f "${nvmPath}"
                source "${nvmPath}" >/dev/null 2>&1
            end
        end
        
        nvm use "$TARGET_VERSION" >/dev/null 2>&1
        if test $status -ne 0
            echo "‚ö†Ô∏è ÁâàÊú¨ $TARGET_VERSION ‰∏çÂ≠òÂú®ÔºåÂ∞ùËØïÂÆâË£Ö..."
            nvm install "$TARGET_VERSION" >/dev/null 2>&1; and nvm use "$TARGET_VERSION" >/dev/null 2>&1
        end
        
        # Fish shell ‰øÆÂ§çÔºöÁâàÊú¨ÂàáÊç¢ÊàêÂäüÂêéËÆæÁΩÆÊÅ¢Â§çÊú∫Âà∂
        function _restore_nvm_version --on-signal INT --on-signal TERM
            echo "üì¶ ÊâßË°åÂÆåÊàêÔºåÊÅ¢Â§çÂà∞‰πãÂâçÁöÑ Node.js ÁâàÊú¨..."
            echo "‚Ü©Ô∏è ÊÅ¢Â§ç Node ÁâàÊú¨: $TARGET_VERSION -> $PREVIOUS_VERSION"
            nvm use "$PREVIOUS_VERSION" >/dev/null 2>&1
        end
    end
    
    # ÊâßË°å npm ÂëΩ‰ª§
    command npm $argv
    set exit_code $status
    
    # Fish shell ‰øÆÂ§çÔºöÊ≠£Â∏∏ÂÆåÊàêÊó∂ÊÅ¢Â§çÁâàÊú¨
    if test -n "$TARGET_VERSION" -a "$TARGET_VERSION" != "$PREVIOUS_VERSION" -a -n "$PREVIOUS_VERSION"
        echo "üì¶ ÊâßË°åÂÆåÊàêÔºåÊÅ¢Â§çÂà∞‰πãÂâçÁöÑ Node.js ÁâàÊú¨..."
        echo "‚Ü©Ô∏è ÊÅ¢Â§ç Node ÁâàÊú¨: $TARGET_VERSION -> $PREVIOUS_VERSION"
        nvm use "$PREVIOUS_VERSION" >/dev/null 2>&1
    end
    
    return $exit_code
end
${HOOK_END_MARKER}
`;
		}

		if (manager === 'n') {
			return `${HOOK_MARKER}
function npm
    set WORKDIRS '${escapedDirsJson}'
    set TARGET_VERSION ""
    set PREVIOUS_VERSION ""
    
    # Ëé∑ÂèñÂΩìÂâç Node ÁâàÊú¨
    if command -v node >/dev/null 2>&1
        set PREVIOUS_VERSION (node -v 2>/dev/null | sed 's/^v//')
    end
    
    # Ê£ÄÊü•ÊòØÂê¶Âú®Â∑•‰ΩúÁõÆÂΩï‰∏≠ÔºàÊîØÊåÅ .nvmrc/.node-version Êñá‰ª∂Ê£ÄÊµãÔºâ
    if test -n "$WORKDIRS"
        set WORKDIR_INFO (echo "$WORKDIRS" | node -e '${versionDetectionJS}' 2>/dev/null)
        
        if test -n "$WORKDIR_INFO"
            set TARGET_VERSION (echo "$WORKDIR_INFO" | cut -d'|' -f1)
            set VERSION_SOURCE (echo "$WORKDIR_INFO" | cut -d'|' -f2)
            set WORKDIR_NAME (echo "$WORKDIR_INFO" | cut -d'|' -f3)
            set SOURCE_FILE (echo "$WORKDIR_INFO" | cut -d'|' -f4)
            
            if test "$VERSION_SOURCE" = "config"
                echo "üìÅ Ê£ÄÊµãÂà∞ÈÖçÁΩÆÈ°πÁõÆ: $WORKDIR_NAME (Node $TARGET_VERSION)"
            else
                echo "üìÅ Ê£ÄÊµãÂà∞È°πÁõÆÁâàÊú¨Êñá‰ª∂: $WORKDIR_NAME (Node $TARGET_VERSION from $SOURCE_FILE)"
            end
        end
    end
    
    # Fish shell ‰øÆÂ§çÔºöÁâàÊú¨ÂàáÊç¢ÂíåÊÅ¢Â§çÊú∫Âà∂
    if test -n "$TARGET_VERSION" -a "$TARGET_VERSION" != "$PREVIOUS_VERSION"
        echo "üîÑ ÂàáÊç¢ Node ÁâàÊú¨: $PREVIOUS_VERSION -> $TARGET_VERSION"
        
        # Ê£ÄÊü•ÁâàÊú¨ÊòØÂê¶Â≠òÂú®ÔºåÂ¶Ç‰∏çÂ≠òÂú®ÂàôÂÆâË£Ö
        if not n ls 2>/dev/null | grep -q "$TARGET_VERSION"
            echo "‚ö†Ô∏è ÁâàÊú¨ $TARGET_VERSION ‰∏çÂ≠òÂú®ÔºåÊ≠£Âú®ÂÆâË£Ö..."
            n install "$TARGET_VERSION" >/dev/null 2>&1
            if test $status -ne 0
                echo "‚ùå ÁâàÊú¨ $TARGET_VERSION ÂÆâË£ÖÂ§±Ë¥•ÔºåÂ∞Ü‰ΩøÁî®ÂΩìÂâçÁâàÊú¨"
                set TARGET_VERSION "$PREVIOUS_VERSION"
            else
                echo "‚úÖ ÁâàÊú¨ $TARGET_VERSION ÂÆâË£ÖÊàêÂäü"
            end
        end
        
        if test "$TARGET_VERSION" != "$PREVIOUS_VERSION"
            n "$TARGET_VERSION" >/dev/null 2>&1
        end
        
        # Fish shell ‰øÆÂ§çÔºöÁâàÊú¨ÂàáÊç¢ÊàêÂäüÂêéËÆæÁΩÆÊÅ¢Â§çÊú∫Âà∂
        function _restore_n_version --on-signal INT --on-signal TERM
            echo "üì¶ ÊâßË°åÂÆåÊàêÔºåÊÅ¢Â§çÂà∞‰πãÂâçÁöÑ Node.js ÁâàÊú¨..."
            echo "‚Ü©Ô∏è ÊÅ¢Â§ç Node ÁâàÊú¨: $TARGET_VERSION -> $PREVIOUS_VERSION"
            n "$PREVIOUS_VERSION" >/dev/null 2>&1
        end
    end
    
    # ÊâßË°å npm ÂëΩ‰ª§
    command npm $argv
    set exit_code $status
    
    # Fish shell ‰øÆÂ§çÔºöÊ≠£Â∏∏ÂÆåÊàêÊó∂ÊÅ¢Â§çÁâàÊú¨
    if test -n "$TARGET_VERSION" -a "$TARGET_VERSION" != "$PREVIOUS_VERSION" -a -n "$PREVIOUS_VERSION"
        echo "üì¶ ÊâßË°åÂÆåÊàêÔºåÊÅ¢Â§çÂà∞‰πãÂâçÁöÑ Node.js ÁâàÊú¨..."
        echo "‚Ü©Ô∏è ÊÅ¢Â§ç Node ÁâàÊú¨: $TARGET_VERSION -> $PREVIOUS_VERSION"
        n "$PREVIOUS_VERSION" >/dev/null 2>&1
    end
    
    return $exit_code
end
${HOOK_END_MARKER}
`;
		}

		return '';
	}

	/**
	 * ‰∏∫ PowerShell ÁîüÊàê Hook
	 */
	private static generatePowerShellHook(
		manager: string,
		workdirs: WorkdirConfig[],
	): string {
		const dirsJson = JSON.stringify(workdirs);

		if (manager === 'nvm-windows') {
			return `${POWERSHELL_HOOK_MARKER}
function npm {
    $WORKDIRS = '${dirsJson}'
    $TARGET_VERSION = ""
    $PREVIOUS_VERSION = ""
    
    # Ëé∑ÂèñÂΩìÂâç Node ÁâàÊú¨
    try {
        $PREVIOUS_VERSION = (node -v 2>$null).Replace("v", "")
    } catch {
        $PREVIOUS_VERSION = ""
    }
    
    # Ê£ÄÊü•ÊòØÂê¶Âú®Â∑•‰ΩúÁõÆÂΩï‰∏≠
    if ($WORKDIRS) {
        try {
            $workdirArray = $WORKDIRS | ConvertFrom-Json
            $currentDir = Get-Location
            
            foreach ($workdir in $workdirArray) {
                $resolvedWorkdir = [System.IO.Path]::GetFullPath($workdir.dir)
                $resolvedCurrent = [System.IO.Path]::GetFullPath($currentDir.Path)
                
                if ($resolvedCurrent.StartsWith($resolvedWorkdir)) {
                    $TARGET_VERSION = $workdir.version
                    Write-Host "üìÅ Ê£ÄÊµãÂà∞ÈÖçÁΩÆÈ°πÁõÆ: $(Split-Path $workdir.dir -Leaf) (Node $TARGET_VERSION)"
                    break
                }
            }
        } catch {
            # ÂøΩÁï• JSON Ëß£ÊûêÈîôËØØ
        }
    }
    
    # ÂàáÊç¢Âà∞ÁõÆÊ†áÁâàÊú¨
    if ($TARGET_VERSION -and $TARGET_VERSION -ne $PREVIOUS_VERSION) {
        Write-Host "üîÑ ÂàáÊç¢ Node ÁâàÊú¨: $PREVIOUS_VERSION -> $TARGET_VERSION"
        nvm use $TARGET_VERSION 2>$null
        if ($LASTEXITCODE -ne 0) {
            Write-Host "‚ö†Ô∏è ÁâàÊú¨ $TARGET_VERSION Êú™ÂÆâË£ÖÔºåÂ∞ùËØïÂÆâË£Ö..."
            nvm install $TARGET_VERSION 2>$null
            if ($LASTEXITCODE -eq 0) {
                Write-Host "‚úÖ ÁâàÊú¨ $TARGET_VERSION ÂÆâË£ÖÊàêÂäü"
                nvm use $TARGET_VERSION 2>$null
            }
        }
    }
    
    # ÊâßË°åÂéüÂßã npm ÂëΩ‰ª§
    & "npm.cmd" @args
    $exitCode = $LASTEXITCODE
    
    # ÂëΩ‰ª§ÊâßË°åÂÆåÊàêÂêéÊÅ¢Â§çÁâàÊú¨
    if ($TARGET_VERSION -and $TARGET_VERSION -ne $PREVIOUS_VERSION -and $PREVIOUS_VERSION) {
        Write-Host "üì¶ ÊâßË°åÂÆåÊàêÔºåÊÅ¢Â§çÂà∞‰πãÂâçÁöÑ Node.js ÁâàÊú¨..."
        Write-Host "‚Ü©Ô∏è ÊÅ¢Â§ç Node ÁâàÊú¨: $TARGET_VERSION -> $PREVIOUS_VERSION"
        nvm use $PREVIOUS_VERSION 2>$null
    }
    
    return $exitCode
}
${POWERSHELL_HOOK_END_MARKER}
`;
		}

		if (manager === 'fnm' || manager === 'nvs') {
			return `${POWERSHELL_HOOK_MARKER}
function npm {
    $WORKDIRS = '${dirsJson}'
    $TARGET_VERSION = ""
    $PREVIOUS_VERSION = ""
    
    # Ëé∑ÂèñÂΩìÂâç Node ÁâàÊú¨
    try {
        $PREVIOUS_VERSION = (node -v 2>$null).Replace("v", "")
    } catch {
        $PREVIOUS_VERSION = ""
    }
    
    # Ê£ÄÊü•ÊòØÂê¶Âú®Â∑•‰ΩúÁõÆÂΩï‰∏≠
    if ($WORKDIRS) {
        try {
            $workdirArray = $WORKDIRS | ConvertFrom-Json
            $currentDir = Get-Location
            
            foreach ($workdir in $workdirArray) {
                $resolvedWorkdir = [System.IO.Path]::GetFullPath($workdir.dir)
                $resolvedCurrent = [System.IO.Path]::GetFullPath($currentDir.Path)
                
                if ($resolvedCurrent.StartsWith($resolvedWorkdir)) {
                    $TARGET_VERSION = $workdir.version
                    Write-Host "üìÅ Ê£ÄÊµãÂà∞ÈÖçÁΩÆÈ°πÁõÆ: $(Split-Path $workdir.dir -Leaf) (Node $TARGET_VERSION)"
                    break
                }
            }
        } catch {
            # ÂøΩÁï• JSON Ëß£ÊûêÈîôËØØ
        }
    }
    
    # ÂàáÊç¢Âà∞ÁõÆÊ†áÁâàÊú¨
    if ($TARGET_VERSION -and $TARGET_VERSION -ne $PREVIOUS_VERSION) {
        Write-Host "üîÑ ÂàáÊç¢ Node ÁâàÊú¨: $PREVIOUS_VERSION -> $TARGET_VERSION"
        ${manager} use $TARGET_VERSION 2>$null
        if ($LASTEXITCODE -ne 0) {
            Write-Host "‚ö†Ô∏è ÁâàÊú¨ $TARGET_VERSION Êú™ÂÆâË£ÖÔºåÂ∞ùËØïÂÆâË£Ö..."
            ${manager} install $TARGET_VERSION 2>$null
            if ($LASTEXITCODE -eq 0) {
                Write-Host "‚úÖ ÁâàÊú¨ $TARGET_VERSION ÂÆâË£ÖÊàêÂäü"
                ${manager} use $TARGET_VERSION 2>$null
            }
        }
    }
    
    # ÊâßË°åÂéüÂßã npm ÂëΩ‰ª§
    & "npm.cmd" @args
    $exitCode = $LASTEXITCODE
    
    # ÂëΩ‰ª§ÊâßË°åÂÆåÊàêÂêéÊÅ¢Â§çÁâàÊú¨
    if ($TARGET_VERSION -and $TARGET_VERSION -ne $PREVIOUS_VERSION -and $PREVIOUS_VERSION) {
        Write-Host "üì¶ ÊâßË°åÂÆåÊàêÔºåÊÅ¢Â§çÂà∞‰πãÂâçÁöÑ Node.js ÁâàÊú¨..."
        Write-Host "‚Ü©Ô∏è ÊÅ¢Â§ç Node ÁâàÊú¨: $TARGET_VERSION -> $PREVIOUS_VERSION"
        ${manager} use $PREVIOUS_VERSION 2>$null
    }
    
    return $exitCode
}
${POWERSHELL_HOOK_END_MARKER}
`;
		}

		return '';
	}

	/**
	 * Ê∑ªÂä† Hook Âà∞ Shell ÈÖçÁΩÆÊñá‰ª∂
	 */
	static addHook(
		shellRcPath: string,
		manager: string,
		workdirs: WorkdirConfig[],
	): void {
		try {
			// Á°Æ‰øùÊñá‰ª∂Â≠òÂú®
			if (!fs.existsSync(shellRcPath)) {
				fs.writeFileSync(shellRcPath, '', 'utf8');
			}

			let content = fs.readFileSync(shellRcPath, 'utf8');

			// ÁßªÈô§Áé∞Êúâ hook
			const regex = new RegExp(
				`${HOOK_MARKER}[\\s\\S]*?${HOOK_END_MARKER}\\n?`,
				'g',
			);
			content = content.replace(regex, '');

			// ÁîüÊàêÊñ∞ hook
			let hook = '';
			const isFishShell = shellRcPath.includes('config.fish');
			const isPowerShell =
				shellRcPath.includes('.ps1') || shellRcPath.includes('PowerShell');

			if (isPowerShell) {
				hook = this.generatePowerShellHook(manager, workdirs);
			} else if (isFishShell) {
				hook = this.generateFishHook(manager, workdirs);
			} else {
				hook = this.generateBashHook(manager, workdirs);
			}

			// Ê∑ªÂä† hook
			const separator = content.endsWith('\n') ? '' : '\n';
			content += `${separator}${hook}`;

			fs.writeFileSync(shellRcPath, content, 'utf8');
			console.log(`‚úÖ Â∑≤ÊàêÂäüÈÖçÁΩÆ ${path.basename(shellRcPath)}`);
		} catch (error) {
			console.error(`‚ùå Êõ¥Êñ∞ ${shellRcPath} Â§±Ë¥•: ${(error as Error).message}`);
		}
	}

	/**
	 * ÁßªÈô§ Shell ÈÖçÁΩÆÊñá‰ª∂‰∏≠ÁöÑ Hook
	 */
	static removeHook(shellRcPath: string): void {
		try {
			if (!fs.existsSync(shellRcPath)) {
				console.warn(`‚ö†Ô∏è Êñá‰ª∂‰∏çÂ≠òÂú®: ${shellRcPath}`);
				return;
			}

			const content = fs.readFileSync(shellRcPath, 'utf8');
			const regex = new RegExp(
				`${HOOK_MARKER}[\\s\\S]*?${HOOK_END_MARKER}\\n?`,
				'g',
			);
			const newContent = content.replace(regex, '');

			if (newContent !== content) {
				fs.writeFileSync(shellRcPath, newContent, 'utf8');
				console.log(`‚úÖ Â∑≤Ê∏ÖÁêÜ ${path.basename(shellRcPath)} ‰∏≠ÁöÑ hook`);
			} else {
				console.log(`‚ÑπÔ∏è ${path.basename(shellRcPath)} ‰∏≠Ê≤°ÊúâÊâæÂà∞ hook`);
			}
		} catch (error) {
			console.error(`‚ùå Ê∏ÖÁêÜ ${shellRcPath} Â§±Ë¥•: ${(error as Error).message}`);
		}
	}

	/**
	 * Ê£ÄÊü• Shell ÈÖçÁΩÆÊñá‰ª∂‰∏≠ÊòØÂê¶Â≠òÂú® Hook
	 */
	static hasHook(shellRcPath: string): boolean {
		try {
			if (!fs.existsSync(shellRcPath)) {
				return false;
			}

			const content = fs.readFileSync(shellRcPath, 'utf8');
			return content.includes(HOOK_MARKER);
		} catch {
			return false;
		}
	}
}
